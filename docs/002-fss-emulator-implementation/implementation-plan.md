# Implementation Plan

## FileShareEmulator — Foundations & Parity Guardrails
- [ ] Work Item 1: Establish emulator boundary + API parity scaffolding (runnable)
  - **Purpose**: Ensure the emulator project is self-contained (no project refs), exposes the required non-controller endpoints (`/health`, `/heartbeat`), and adds a parity safety net so subsequent work can iterate without drifting from production.
  - **Acceptance Criteria**:
    - Emulator builds and runs locally.
    - No new project references are added to the emulator project.
    - Existing Blazor UI routes remain unchanged.
    - `GET /health` and `GET /heartbeat` respond as they do today.
    - A basic parity check mechanism exists (snapshot/spec-based) to track routes and contracts.
  - **Definition of Done**:
    - Code compiles and app starts.
    - Initial parity artifact is generated/committed.
    - Tests (smoke) pass.
    - Can execute end-to-end via: `dotnet run` and calling `/health` + `/heartbeat`.
  - [ ] Task 1: Locate emulator project and confirm constraints
    - [ ] Step 1: Identify the emulator project file (`*.csproj`) and confirm it has no `<ProjectReference>` items.
    - [ ] Step 2: Document where controllers/endpoints will live inside the emulator project (e.g., `Controllers/`, `Endpoints/`, `Models/`).
  - [ ] Task 2: Add API surface inventory artifacts
    - [ ] Step 1: Create a checked-in API inventory file (route table) derived from the spec’s section 12.
    - [ ] Step 2: Add a lightweight automated test that asserts the presence of all expected routes (verb + template) for the emulator host.
  - **Files**:
    - `docs/002-fss-emulator-implementation/api-inventory.md`: Human-readable route inventory used by parity tests.
    - `src/<EmulatorProject>/Tests/<...>`: Route-smoke tests (exact location TBD after discovery).
  - **Work Item Dependencies**: None.
  - **Run / Verification Instructions**:
    - `dotnet test`
    - `dotnet run --project <emulator-project>`
    - `curl http://localhost:<port>/health`
    - `curl http://localhost:<port>/heartbeat`
  - **User Instructions**:
    - Ensure `/data/content` exists and is writable in the runtime environment (or provide a dev override for local runs if required by existing setup).

## FileShareEmulator — Vertical Slice: Create Batch + Write File (filesystem)
- [ ] Work Item 2: Start batch and allow adding a file to an uncommitted batch (runnable)
  - **Purpose**: Deliver the smallest meaningful FSS capability end-to-end: create a batch, create its working directory, and upload a file into it.
  - **Acceptance Criteria**:
    - `POST /batch` creates a new batch and working directory at `/data/content/{IDprefix}/{BatchId}/`.
    - `POST /batch/{batchId}/files/{fileName}` writes content into the batch working directory.
    - Concurrency rule enforced: first writer to the same relative path wins; subsequent writes return conflict.
    - No auth is required; no 401/403 are returned for missing creds.
  - **Definition of Done**:
    - Controllers and DTOs exist in emulator project and match production routes/contracts.
    - Files are written to the required filesystem layout.
    - Logging for directory creation and file writes exists.
    - Unit tests for ID prefix derivation and conflict behaviour.
    - Integration tests for create batch + add file.
    - Can execute end-to-end via: HTTP calls to create batch and upload.
  - [ ] Task 1: Replicate controller shape for `BatchController` start batch
    - [ ] Step 1: Implement `POST /batch` action with production-aligned response contract.
    - [ ] Step 2: Generate `BatchId` as `Guid` and persist/return in the same shape as production.
    - [ ] Step 3: Create working directory as specified.
  - [ ] Task 2: Replicate controller shape for `FileController` add file
    - [ ] Step 1: Implement `POST /batch/{batchId}/files/{fileName}`.
    - [ ] Step 2: Stream request body to filesystem path under batch directory.
    - [ ] Step 3: Implement per-path locking + conflict response if file already exists.
  - [ ] Task 3: Implement `{IDprefix}` derivation helper
    - [ ] Step 1: Port the canonical algorithm described (based on `Guid.TryWriteBytes`).
    - [ ] Step 2: Add unit tests with known GUID ? prefix cases.
  - **Files**:
    - `src/<EmulatorProject>/Controllers/BatchController.cs`: `POST /batch`.
    - `src/<EmulatorProject>/Controllers/FileController.cs`: `POST /batch/{batchId}/files/{fileName}`.
    - `src/<EmulatorProject>/Storage/FileSystemBatchStorage.cs`: Filesystem layout + write operations.
    - `src/<EmulatorProject>/Storage/Locking/<...>.cs`: Per-batch/per-path locking.
    - `src/<EmulatorProject>/Common/BatchIdPrefix.cs`: Prefix derivation.
    - `src/<EmulatorProject>.Tests/<...>`: Unit + integration tests.
  - **Work Item Dependencies**: Work Item 1.
  - **Run / Verification Instructions**:
    - `dotnet test`
    - `curl -X POST http://localhost:<port>/batch`
    - `curl -X POST --data-binary @file.txt http://localhost:<port>/batch/<batchId>/files/file.txt`

## FileShareEmulator — Vertical Slice: Commit Batch (zip + delete)
- [ ] Work Item 3: Commit a batch to `{BatchId}.zip` and delete working directory (runnable)
  - **Purpose**: Implement the core lifecycle transition from working directory to committed zip, matching conflict and cleanup semantics.
  - **Acceptance Criteria**:
    - `PUT /batch/{batchId}` creates `/data/content/{IDprefix}/{BatchId}.zip` containing only the *contents* of the batch dir.
    - If the zip already exists, return conflict and do not modify it.
    - After successful zip creation, attempt to delete the working directory.
    - If deletion fails, still return success and log the cleanup failure.
  - **Definition of Done**:
    - Zip creation is best-effort atomic (temp file then move).
    - Logging includes zip creation + deletion failure.
    - Integration tests cover happy path, zip-exists conflict, and deletion-failure logging (where feasible).
    - Can execute end-to-end via: create batch ? upload file ? commit ? verify zip.
  - [ ] Task 1: Implement commit endpoint in `BatchController`
    - [ ] Step 1: Add `PUT /batch/{batchId}` action with production-aligned response.
    - [ ] Step 2: Validate batch state (minimal initially, then align to production as discovered).
  - [ ] Task 2: Implement zipping and cleanup
    - [ ] Step 1: Zip directory contents (no `{BatchId}` root folder in archive).
    - [ ] Step 2: Write to temp zip, then move into place.
    - [ ] Step 3: Delete working dir; on failure, log warning but return success.
  - **Files**:
    - `src/<EmulatorProject>/Controllers/BatchController.cs`: `PUT /batch/{batchId}`.
    - `src/<EmulatorProject>/Storage/FileSystemBatchStorage.cs`: `CommitAsync` implementation.
    - `src/<EmulatorProject>.Tests/<...>`: Integration tests for commit.
  - **Work Item Dependencies**: Work Item 2.
  - **Run / Verification Instructions**:
    - `dotnet test`
    - `curl -X PUT http://localhost:<port>/batch/<batchId>`
    - Verify file exists at `/data/content/<prefix>/<batchId>.zip`.

## FileShareEmulator — Vertical Slice: Download / Retrieve Content
- [ ] Work Item 4: Retrieve a file and/or download batch as zip (runnable)
  - **Purpose**: Provide a consumer-visible capability to read back what was stored, matching production endpoints.
  - **Acceptance Criteria**:
    - `GET /batch/{batchId}/files/{filename}` returns the stored file with correct content type/headers (as production).
    - `GET /batch/{batchId}/files` returns a zip of the batch contents (as production).
    - Works for uncommitted (directory) and committed (zip) batches if production supports it; otherwise align to production behaviour.
  - **Definition of Done**:
    - Streaming read implementation.
    - Integration tests cover file download and zip download.
  - [ ] Task 1: Implement `GET file` action
    - [ ] Step 1: Determine source path (directory vs zip) and stream response.
  - [ ] Task 2: Implement `GET files as zip` action
    - [ ] Step 1: For directory batches, zip on the fly or stage temp.
    - [ ] Step 2: For committed batches, serve the existing `{BatchId}.zip` where appropriate.
  - **Files**:
    - `src/<EmulatorProject>/Controllers/FileController.cs`: `GET /batch/{batchId}/files/{filename}`, `GET /batch/{batchId}/files`.
    - `src/<EmulatorProject>/Storage/FileSystemBatchStorage.cs`: read/zip helpers.
    - `src/<EmulatorProject>.Tests/<...>`: integration tests.
  - **Work Item Dependencies**: Work Item 3.
  - **Run / Verification Instructions**:
    - `curl -OJ http://localhost:<port>/batch/<batchId>/files/file.txt`
    - `curl -OJ http://localhost:<port>/batch/<batchId>/files`

## FileShareEmulator — API Completion: Remaining Controllers
- [ ] Work Item 5: Implement remaining required endpoints with production-aligned contracts (runnable)
  - **Purpose**: Fill out the rest of the production surface listed in the spec inventory while keeping each step runnable.
  - **Acceptance Criteria**:
    - All endpoints listed in spec section 12 exist and return production-aligned status codes and error shapes.
    - `DELETE /batch/{batchId}` rollback deletes working dir (and/or handles committed state) as production.
    - `GET /batch/{batchId}/status`, `PUT /batch/{batchId}/expiry`, `GET /batch/{batchId}`, `GET /batch`, attributes endpoints, ACL endpoints, and file block endpoints behave in a production-aligned way.
    - No Swagger endpoints are exposed.
  - **Definition of Done**:
    - Integration tests for each endpoint.
    - Route parity test passes.
  - [ ] Task 1: Implement `FileBlockController` (block upload)
    - [ ] Step 1: Implement `PUT /batch/{batchId}/files/{fileName}/{blockId}` using the same block semantics as production (to be derived by inspecting prod).
  - [ ] Task 2: Implement `AclController`
    - [ ] Step 1: Implement append/get/replace ACL endpoints.
    - [ ] Step 2: Persist ACL state in DB matching production.
  - [ ] Task 3: Implement batch query + attributes endpoints
    - [ ] Step 1: Implement `GET /batch` filtering/paging as production.
    - [ ] Step 2: Implement attributes list / search endpoints.
  - **Files**:
    - `src/<EmulatorProject>/Controllers/FileBlockController.cs`
    - `src/<EmulatorProject>/Controllers/AclController.cs`
    - `src/<EmulatorProject>/Controllers/BatchController.cs`
    - `src/<EmulatorProject>/Controllers/AttributesController.cs` (if production has one)
    - `src/<EmulatorProject>.Tests/<...>`
  - **Work Item Dependencies**: Work Item 4.
  - **Run / Verification Instructions**:
    - `dotnet test`
    - Run a Postman/HTTP collection against all routes.

## FileShareEmulator — Database Parity
- [ ] Work Item 6: Implement database updates to match production FSS API (runnable)
  - **Purpose**: Ensure DB side-effects match production (order + values) while keeping emulator project self-contained.
  - **Acceptance Criteria**:
    - For each endpoint that mutates state, DB updates are equivalent to production.
    - Uses the existing Aspire SQL client configuration.
    - EF Core model/migrations (or schema mapping) align with required state.
  - **Definition of Done**:
    - DB integration tests validate resulting rows/values for key workflows.
    - Logging around DB updates and failures.
  - [ ] Task 1: Discover production DB behaviour
    - [ ] Step 1: Inspect production code/migrations (outside emulator project) to capture required tables, columns, and update order.
    - [ ] Step 2: Encode this as a parity document in `docs/`.
  - [ ] Task 2: Implement EF Core persistence in emulator
    - [ ] Step 1: Add entity models and `DbContext` inside emulator project.
    - [ ] Step 2: Wire up Aspire SQL connection.
    - [ ] Step 3: Implement repository/services used by controllers.
  - **Files**:
    - `docs/002-fss-emulator-implementation/db-parity-notes.md`: Captured production update behaviour.
    - `src/<EmulatorProject>/Persistence/<...>.cs`: Entities, `DbContext`, repositories.
    - `src/<EmulatorProject>.Tests/<...>`: DB integration tests.
  - **Work Item Dependencies**: Work Item 2–5 (as endpoints dictate DB needs).
  - **Run / Verification Instructions**:
    - `dotnet test`
    - Run emulator with DB configured; execute create batch ? upload ? commit flow and verify DB state.

## FileShareEmulator — Operational Hardening
- [ ] Work Item 7: Operational readiness (logging, configuration, container correctness)
  - **Purpose**: Ensure predictable runtime behaviour in container/Linux with filesystem constraints.
  - **Acceptance Criteria**:
    - `/data/content` existence is validated on startup with a clear error.
    - Logging covers batch lifecycle and cleanup failures.
    - Concurrency strategy is stable under load tests.
  - **Definition of Done**:
    - Smoke tests in container-like environment (where available).
  - [ ] Task 1: Startup checks and configuration
    - [ ] Step 1: Validate write access to `/data/content`.
  - [ ] Task 2: Add multi-request concurrency tests
    - [ ] Step 1: Parallel uploads to distinct paths succeed.
    - [ ] Step 2: Parallel uploads to same path produce conflict for losers.
  - **Files**:
    - `src/<EmulatorProject>/Program.cs` (or equivalent): startup validation.
    - `src/<EmulatorProject>.Tests/<...>`: concurrency tests.
  - **Work Item Dependencies**: Work Item 3.
  - **Run / Verification Instructions**:
    - `dotnet test`
    - Container run instructions (as per repo).
